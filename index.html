<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>R-code</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        :root {
            --bg-color: #000000;
            --text-color: #00FF00; /* Bright Green */
            --primary-color: #00FF00;
            --secondary-color: #0d0d0d;
            --border-color: #008000; /* Darker Green */
            --error-color: #FF4136;
        }

        body {
            font-family: 'Courier New', Courier, monospace; /* Classic terminal font */
            background-color: var(--bg-color);
            color: var(--text-color);
            text-shadow: 0 0 2px var(--primary-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        #app {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin: 0;
            letter-spacing: 4px;
            text-transform: uppercase;
        }
        
        .author {
            text-align: center;
            color: var(--border-color);
            margin: -10px 0 10px 0;
            font-size: 0.9em;
        }

        .warning-box {
            background-color: #00ff000f;
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 0;
            text-align: center;
            font-size: 0.9em;
        }

        .card {
            background-color: var(--secondary-color);
            padding: 25px;
            border-radius: 0;
            border: 1px solid var(--border-color);
        }

        textarea, input[type="password"] {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border-radius: 0;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: inherit;
            font-size: 1em;
            box-sizing: border-box;
            resize: vertical;
            text-shadow: 0 0 2px var(--primary-color);
        }

        textarea:focus, input[type="password"]:focus {
            outline: 1px solid var(--primary-color);
            box-shadow: 0 0 10px var(--primary-color);
        }
        
        textarea {
            min-height: 150px;
        }

        .actions {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 20px;
            border: 1px solid var(--primary-color);
            border-radius: 0;
            background-color: var(--primary-color);
            color: var(--bg-color);
            font-family: inherit;
            font-size: 1em;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
        }

        button:hover {
            background-color: var(--bg-color);
            color: var(--primary-color);
        }
        
        button:disabled {
            background-color: #555;
            border-color: #555;
            color: #999;
            cursor: not-allowed;
            text-shadow: none;
        }
        
        .result-box {
            margin-top: 20px;
            word-wrap: break-word;
            white-space: pre-wrap;
            background-color: var(--bg-color);
            padding: 15px;
            border: 1px dashed var(--border-color);
            min-height: 50px;
        }

        .error-message {
            color: var(--error-color);
            font-weight: bold;
            text-shadow: 0 0 5px var(--error-color);
        }
        
        .loading-indicator {
            text-align: center;
            padding: 10px;
        }

    </style>
</head>
<body>

<div id="app">
    <h1>R-code ðŸ“Ÿ</h1>
    <p class="author">dibuat oleh rxh</p>
    
    <div class="warning-box">
        <strong>PERHATIAN:</strong> Semua proses terjadi di browser Anda. Lupa kata kunci akan menyebabkan data hilang selamanya. Kami tidak bisa memulihkannya.
    </div>

    <div class="card">
        <textarea v-model="text" placeholder="[type text to encrypt // paste encrypted text to decrypt]"></textarea>
        
        <input type="password" v-model="passphrase" placeholder="[enter secret key]">

        <div class="actions">
            <button @click="encrypt" :disabled="!text || !passphrase || isLoading">
                {{ isLoading ? 'processing...' : 'Encrypt' }}
            </button>
            <button @click="decrypt" :disabled="!text || !passphrase || isLoading">
                {{ isLoading ? 'processing...' : 'Decrypt' }}
            </button>
        </div>
        
        <div v-if="isLoading" class="loading-indicator">
            > running cryptographic sequence...
        </div>

        <div v-if="output || error" class="result-box">
            <pre v-if="output">{{ output }}</pre>
            <p v-if="error" class="error-message">> {{ error }}</p>
        </div>
    </div>
</div>

<script>
    const utils = {
        arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        },
        base64ToArrayBuffer(base64) {
            const binary_string = window.atob(base64);
            const len = binary_string.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binary_string.charCodeAt(i);
            }
            return bytes.buffer;
        }
    };

    Vue.createApp({
        data() {
            return {
                text: '',
                passphrase: '',
                output: '',
                error: '',
                isLoading: false
            };
        },
        methods: {
            async getKey(passphrase, salt) {
                const enc = new TextEncoder();
                const keyMaterial = await window.crypto.subtle.importKey(
                    'raw',
                    enc.encode(passphrase),
                    { name: 'PBKDF2' },
                    false,
                    ['deriveKey']
                );
                return window.crypto.subtle.deriveKey(
                    {
                        "name": 'PBKDF2',
                        salt: salt,
                        "iterations": 600000,
                        "hash": 'SHA-256'
                    },
                    keyMaterial,
                    { "name": 'AES-GCM', "length": 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
            },
            
            async encrypt() {
                if (!this.text || !this.passphrase) return;
                this.isLoading = true;
                this.output = '';
                this.error = '';

                try {
                    const salt = window.crypto.getRandomValues(new Uint8Array(16));
                    const iv = window.crypto.getRandomValues(new Uint8Array(12));
                    const key = await this.getKey(this.passphrase, salt);
                    
                    const enc = new TextEncoder();
                    const encodedText = enc.encode(this.text);

                    const ciphertext = await window.crypto.subtle.encrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        encodedText
                    );

                    const saltB64 = utils.arrayBufferToBase64(salt);
                    const ivB64 = utils.arrayBufferToBase64(iv);
                    const ciphertextB64 = utils.arrayBufferToBase64(ciphertext);

                    this.output = `${saltB64}.${ivB64}.${ciphertextB64}`;

                } catch (e) {
                    this.error = 'ERROR: Encryption sequence failed.';
                } finally {
                    this.isLoading = false;
                }
            },

            async decrypt() {
                if (!this.text || !this.passphrase) return;
                this.isLoading = true;
                this.output = '';
                this.error = '';

                try {
                    const parts = this.text.split('.');
                    if (parts.length !== 3) {
                        throw new Error('Invalid encrypted data format.');
                    }
                    
                    const salt = utils.base64ToArrayBuffer(parts[0]);
                    const iv = utils.base64ToArrayBuffer(parts[1]);
                    const ciphertext = utils.base64ToArrayBuffer(parts[2]);

                    const key = await this.getKey(this.passphrase, salt);

                    const decrypted = await window.crypto.subtle.decrypt(
                        { name: 'AES-GCM', iv: iv },
                        key,
                        ciphertext
                    );

                    const dec = new TextDecoder();
                    this.output = dec.decode(decrypted);

                } catch (e) {
                    this.error = 'ERROR: Decryption failed. Invalid key or corrupt data.';
                } finally {
                    this.isLoading = false;
                }
            }
        }
    }).mount('#app');
</script>

</body>
</html>
